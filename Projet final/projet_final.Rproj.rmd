---
title: "Analyse g√©ocimique de la surface de Mercure √† partir des donn√©es MESSENGER"
author: "Alexandre Michaux & Beniamino Orsini"
date: "`r Sys.Date()`"
output:
  html_document:
    css: "retro.css"
    toc: true
    toc_float: true
    number_sections: true
    code_folding: hide   # <-- code cach√© par d√©faut, bouton pour afficher
    df_print: paged
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  echo = FALSE,
  eval = T,
  fig.align = "center",
  fig.width = 7,
  fig.height = 5
)
```

# Pr√©sentation du projet

Ce projet s‚Äôinscrit dans le cadre du module d‚Äôanalyse de donn√©es et vise √† √©tudier la **composition g√©ochimique de la surface de Mercure** √† partir des donn√©es orbitales issues de la mission **MESSENGER**.  
L‚Äôobjectif global est de relier les **h√©t√©rog√©n√©it√©s chimiques de surface** √† l‚Äô**histoire magmatique** et √† l‚Äô**√©volution interne** de la plan√®te.

## La mission MESSENGER

La mission *MESSENGER (MErcury Surface, Space ENvironment, GEochemistry, and Ranging)*, lanc√©e par la NASA en 2004 et mise en orbite autour de Mercure en mars 2011, a fourni jusqu‚Äô√† 2015 un ensemble complet de donn√©es sur la g√©ochimie, la topographie et le champ magn√©tique de la plan√®te.  
Les donn√©es utilis√©es ici proviennent principalement de deux instruments :

- **XRS (X-Ray Spectrometer)** : mesure des rapports √©l√©mentaires de surface (Mg/Si, Al/Si, Ca/Si, Fe/Si, S/Si).  
- **MLA (Mercury Laser Altimeter)** : mesure de la topographie et de l‚Äôaltitude absolue des terrains.

Ces informations permettent de produire des **cartes globales de composition chimique**, repr√©sentatives des terrains volcaniques et de l‚Äô√©volution du manteau mercurien.

Les donn√©es utilis√©es dans ce projet proviennent principalement de l‚Äôinstrument XRS (X-Ray Spectrometer) pour la g√©ochimie et de l‚Äôinstrument MLA (Mercury Laser Altimeter) pour la topographie fournie par la publication de [Nittler *et al.* (2020)](#nittler2020).
	
## Objectifs du projet

Le but de ce travail est double :

1. **Consolider les donn√©es MESSENGER** pour obtenir un cube global (latitude √ó longitude √ó variable) repr√©sentant les principaux rapports g√©ochimiques de la surface de Mercure.
2. **Comparer ces compositions orbitales** √† des **exp√©riences de fusion partielle** r√©alis√©es en laboratoire (s√©ries Mer8 et Mer15) afin d‚Äôen d√©duire des **cartes globales de pression de fusion** et de **taux de fusion partielle (F)**.
3. Etablir un jeu de donn√©es statistiques et cartographiques complet, permettant d‚Äô√©tudier les relations entre composition chimique, topographie.

Cette approche permet de relier chaque pixel de la surface mercurienne √† des conditions exp√©rimentales de fusion, et donc √† des profondeurs ou degr√©s de fusion du manteau.

# Pr√©paration et traitement des donn√©es

Les donn√©es brutes sont constitu√©es de plusieurs fichiers de formats vari√©s (`.bmp`, `.png`, `.dat`, `.rds`), chacun repr√©sentant une variable g√©ochimique ou g√©ophysique.  
Avant toute analyse, ces couches sont **uniformis√©es** et **empil√©es** dans un **cube tridimensionnel** (latitude √ó longitude √ó variable).  
Chaque couche correspond √† une carte globale : par exemple, les rapports **Mg/Si**, **Al/Si**, **Ca/Si**, **Fe/Si** et **S/Si**.

Les √©tapes principales sont les suivantes :

1. **Chargement automatique** des fichiers pr√©sents dans le dossier `data/`, avec lecture adapt√©e selon le format.  
2. **Application de facteurs de correction** pour convertir les intensit√©s (valeurs 0‚Äì255 des BMP/PNG) en valeurs normalis√©es de rapport √©l√©mentaire.  
3. **Redimensionnement** de toutes les couches √† une grille uniforme de **720 √ó 1440 pixels** (r√©solution latitude‚Äìlongitude).  
4. **Cr√©ation d‚Äôun masque commun** √©liminant les pixels invalides (valeurs nulles ou < 0.0001).  
5. **Empilement final** des couches corrig√©es et masqu√©es dans un objet 3D `result_array_full`, sauvegard√© au format `.rds`.

Le code effectue ensuite un contr√¥le statistique du cube (nombre de pixels valides, distribution des valeurs) et permet une visualisation rapide de chaque couche via la fonction `image()`, dont le titre correspond automatiquement au nom du fichier source.





```{r}
rm(list=ls())

# ==================== PACKAGES ====================
packages <- c("raster","bmp","png","rstudioapi","abind","plotly")
installed_packages <- packages %in% installed.packages()[,"Package"]
if (any(!installed_packages)) install.packages(packages[!installed_packages])
lapply(packages, library, character.only = TRUE)

# ==================== CHEMINS ====================
base_path <- dirname(rstudioapi::getSourceEditorContext()$path)
directory_path <- file.path(base_path, "data")
result_file <- file.path(base_path, "result_array_with_uncertainty.rds")

# ==================== UTILS ====================
from03602180 <- function(mat) {
  middle <- dim(mat)[2] / 2
  cbind(mat[, (middle + 1):(2 * middle)], mat[, 1:middle])
}

resize_to_target <- function(mat, target_dim = c(720,1440)) {
  if (is.null(dim(mat))) stop("Matrix has no dimensions.")
  if (all(dim(mat) == target_dim)) return(mat)
  r <- raster::raster(mat)
  r_target <- raster::raster(nrows = target_dim[1], ncols = target_dim[2])
  r_resized <- raster::resample(r, r_target, method = "bilinear")
  as.matrix(r_resized)
}

# ==================== FONCTION DE LECTURE DES COUCHES ====================
process_files_to_3d_array <- function(directory_path, correction_factors = NULL, target_dim = c(720, 1440)) {
  # -------------------------------------------------------
  # Charge BMP / PNG / DAT / RDS d'un dossier,
  # applique une √©ventuelle correction par fichier,
  # redimensionne √† target_dim et empile en tableau 3D.
  # (CSV exclus, tous les RDS inclus)
  # -------------------------------------------------------
  
  # Liste des fichiers, en excluant explicitement CSV et TIFF
  file_list <- list.files(directory_path, full.names = TRUE)
  file_list <- file_list[!grepl("\\.csv$", file_list, ignore.case = TRUE)]
  file_list <- file_list[!grepl("\\.tif(f)?$", file_list, ignore.case = TRUE)]
  # Ne garder que les extensions g√©r√©es
  file_list <- file_list[grepl("\\.(bmp|png|dat|rds)$", file_list, ignore.case = TRUE)]
  
  n_files <- length(file_list)
  if (n_files == 0) stop("Aucun fichier pris en charge (BMP/PNG/DAT/RDS) dans : ", directory_path)
  
  layer_names <- basename(file_list)
  array_3d <- array(NA_real_, dim = c(target_dim[1], target_dim[2], n_files))
  
  apply_correction <- function(m, cf) {
    if (is.null(cf)) return(m)
    m * cf
  }
  
  for (i in seq_along(file_list)) {
    file_path <- file_list[i]
    file_name <- layer_names[i]
    ext <- tolower(tools::file_ext(file_name))
    message("‚Üí Lecture de ", file_name)
    
    if (ext == "bmp") {
      # BMP : lecture brute, orientation inchang√©e
      m <- read.bmp(file_path)
      mode(m) <- "numeric"
      m <- apply_correction(m, correction_factors[[file_name]])
      m <- resize_to_target(m, target_dim)
      array_3d[,,i] <- m
      
    } else if (ext == "png") {
      # PNG : via raster -> matrice ; flip vertical pour redresser
      m <- as.matrix(raster::raster(file_path))
      mode(m) <- "numeric"
      m <- apply_correction(m, correction_factors[[file_name]])
      m <- resize_to_target(m, target_dim)
      m <- m[nrow(m):1, ]  # redressement vertical
      array_3d[,,i] <- m
      
    } else if (ext == "dat") {
      # DAT : structure sp√©ciale -> recollage + (dans ta version) inversion L/C
      m <- from03602180(as.matrix(read.table(file_path, header = FALSE)))
      mode(m) <- "numeric"
      m <- apply_correction(m, correction_factors[[file_name]])
      m <- resize_to_target(m, target_dim)
      array_3d[,,i] <- m
      
    } else if (ext == "rds") {
      # RDS : on prend TOUT fichier .rds
      m <- readRDS(file_path)
      mode(m) <- "numeric"
      m <- apply_correction(m, correction_factors[[file_name]])
      m <- resize_to_target(m, target_dim)
      array_3d[,,i] <- m
      
    } else {
      warning("‚ö†Ô∏è Type non support√©/ignor√© : ", file_name)
      next
    }
  }
  
  attr(array_3d, "layer_names") <- layer_names
  array_3d
}
# ==================== FACTEURS DE CORRECTION ====================
correction_factors <- list(
  "mgsi.bmp"    = 0.860023 / 255.0,
  "alsi.bmp"    = 0.402477 / 255.0,
  "ssi.bmp"     = 0.161680 / 255.0,
  "fesi.bmp"    = 0.117737 / 255.0,
  "casi.bmp"    = 0.318000 / 255.0,
  "mgsierr.png" = 0.223226 / 255.0,
  "alsierr.png" = 0.153596 / 255.0,
  "ssierr.png"  = 0.0398775 / 255.0,
  "fesierr.png" = 0.0283532 / 255.0,
  "casierr.png" = 0.0809775 / 255.0
)

# ==================== CONSTRUCTION DU CUBE ====================
result_array <- process_files_to_3d_array(directory_path, correction_factors)
layer_names  <- attr(result_array, "layer_names")
cat("‚úÖ Cube initial charg√© :", dim(result_array)[3], "couches\n")

# ==================== MASQUE COMMUN (5 RAPPORTS .bmp) ====================
idx_mgsi <- grep("^mgsi\\.bmp$", layer_names, ignore.case = TRUE)
idx_alsi <- grep("^alsi\\.bmp$", layer_names, ignore.case = TRUE)
idx_casi <- grep("^casi\\.bmp$", layer_names, ignore.case = TRUE)
idx_fesi <- grep("^fesi\\.bmp$", layer_names, ignore.case = TRUE)
idx_ssi  <- grep("^ssi\\.bmp$",  layer_names, ignore.case = TRUE)

if (any(lengths(list(idx_mgsi,idx_alsi,idx_casi,idx_fesi,idx_ssi)) == 0)) {
  stop("‚ùå Introuvable : au moins une des couches mgsi/alsi/casi/fesi/ssi (.bmp).")
}

# On consid√®re qu‚Äôune valeur < 0.0001 = pixel invalide
mask_common <- (result_array[,,idx_mgsi]  > 0.0001) &
  (result_array[,,idx_alsi]  > 0.0001) &
  (result_array[,,idx_casi]  > 0.0001) &
  (result_array[,,idx_fesi]  > 0.0001) &
  (result_array[,,idx_ssi]   > 0.0001)

# ==================== CUBE MASQU√â (NA sur pixels invalides) ====================
masked_cube <- array(NA_real_, dim = dim(result_array))
for (i in 1:dim(result_array)[3]) {
  L <- result_array[,,i]
  L[!mask_common] <- NA_real_
  masked_cube[,,i] <- L
}

# ==================== CONCAT√âNER : ORIGINAL + MASQU√â ====================
result_array_full <- abind::abind(result_array, masked_cube, along = 3)
attr(result_array_full, "layer_names") <- c(layer_names, paste0(layer_names, "_masked"))

cat("‚úÖ Cube final :", dim(result_array_full)[3], "couches (doubl√©)\n")

# ==================== STATISTIQUES DES COUCHES ====================
na_counts <- sapply(1:dim(result_array_full)[3], function(i) sum(is.na(result_array_full[,,i])))
layer_info <- data.frame(
  Index = seq_along(attr(result_array_full, "layer_names")),
  Layer = attr(result_array_full, "layer_names"),
  NA_Count = na_counts
)
cat("\n=== STATISTIQUES DES COUCHES ===\n")
print(layer_info)

# ==================== SAUVEGARDE ====================
saveRDS(result_array_full, file = result_file)
cat("\nüíæ Sauvegard√© :", result_file, "\n")

result_array_full[result_array_full == 0 | abs(result_array_full) < 1e-10] <- NA_real_
#nombre de NA dans chaque couche
na_counts <- sapply(1:dim(result_array_full)[3], function(i) sum(is.na(result_array_full[,,i])))
layer_info <- data.frame(Index = seq_along(attr(result_array_full, "layer_names")), Layer = attr(result_array_full, "layer_names"), NA_Count = na_counts)
print(layer_info) # Afficher les informations des couches avec le nombre de

```

La fonction ci-dessous permet d'extraire une matrice 2D (une couche) du tableau 3D en fonction de l'index de la couche et de potentiellement l'afficher.

```{r}
get_layer_as_matrix <- function(result_array, layer_index) {

  if (layer_index < 1 || layer_index > dim(result_array)[3]) { #check si l'index est inf. √† 1 (index minimum) ou si il est sup. au nombre de couche de result_array
    stop("Layer index out of bounds.")
  }
  return(result_array[,,layer_index])   # Extrait et retourne la couche sp√©cifi√©e sous forme de matrice
}

# Boucle d'affichage avec titre = nom du fichier
for (i in seq_along(layer_names)) {
  layer_matrix <- get_layer_as_matrix(result_array_full, i)
  
  image(
    z = t(apply(layer_matrix, 2, rev)),   # rotation correcte pour l'affichage
    col = terrain.colors(100),
    main = paste("Couche", i, "-", layer_names[i]),  # Titre avec nom de fichier
    axes = FALSE,
    xlab = "Longitude",
    ylab = "Latitude"
  )
}
```

## Int√©gration des donn√©es exp√©rimentales

Pour relier les compositions observ√©es √† la surface de Mercure √† des conditions physiques (pression, temp√©rature, taux de fusion partielle), deux jeux de donn√©es exp√©rimentales sont utilis√©s :

- **Mer8** et **Mer15**, correspondant √† deux compositions de d√©part diff√©rentes du manteau mercurien.  
  Ces exp√©riences de fusion partielle ont √©t√© conduites √† des pressions de **1.5, 3 et 5 GPa** et des temp√©ratures comprises entre **1475¬∞C et 1700¬∞C**.

Chaque ligne de ces fichiers (`data_Mer8.csv`, `data_Mer15.csv`) contient :
- la pression exp√©rimentale,
- le taux de fusion partielle (F),
- et les rapports chimiques correspondants (Mg/Si, Al/Si, Ca/Si, Fe/Si, S/Si).

Les deux s√©ries sont combin√©es pour constituer un ensemble de r√©f√©rence unique (`exp_data`), utilis√© pour comparer les compositions de surface pixel par pixel.

```{r}
mer8_path  <- "/Users/alexandremichaux/Documents/UCA/Cours/Analyse des donneÃÅes/TP/TPs/Projet final/data/data_Mer8.csv"
mer15_path <- "/Users/alexandremichaux/Documents/UCA/Cours/Analyse des donneÃÅes/TP/TPs/Projet final/data/data_Mer15.csv"

data_Mer8  <- read.csv(mer8_path,  sep = ",", header = TRUE, check.names = FALSE, stringsAsFactors = FALSE)
data_Mer15 <- read.csv(mer15_path, sep = ",", header = TRUE, check.names = FALSE, stringsAsFactors = FALSE)

# Combiner les deux jeux exp√©rimentaux
exp_data <- rbind(data_Mer8, data_Mer15)
exp_data <- exp_data[complete.cases(exp_data[, c("Mg/Si","Al/Si","Ca/Si","Fe/Si","S/Si")]), ]
```


## M√©thode de corr√©lation g√©ochimique

L‚Äôobjectif est d‚Äôassocier chaque pixel de Mercure √† la **condition exp√©rimentale la plus proche** parmi les donn√©es Mer8/Mer15.  
Pour cela, on calcule pour chaque pixel un **r√©sidu pond√©r√©** mesurant la diff√©rence entre la composition observ√©e et la composition exp√©rimentale.

---

### Calcul du r√©sidu pond√©r√©

Pour chaque pixel $(x, y)$, on d√©finit un **vecteur de mesures** :

\[
\mathbf{M}(x, y) = 
\begin{pmatrix}
\mathrm{Mg/Si} \\
\mathrm{Al/Si} \\
\mathrm{Ca/Si} \\
\mathrm{Fe/Si} \\
\mathrm{S/Si}
\end{pmatrix}
\]

et les **incertitudes correspondantes** :

\[
\boldsymbol{\sigma} = 
\begin{pmatrix}
\sigma_{\mathrm{Mg/Si}} \\
\sigma_{\mathrm{Al/Si}} \\
\sigma_{\mathrm{Ca/Si}} \\
\sigma_{\mathrm{Fe/Si}} \\
\sigma_{\mathrm{S/Si}}
\end{pmatrix}
\]

Pour chaque exp√©rience $E_i$ du jeu **Mer8/Mer15**, on calcule le **r√©sidu pond√©r√©** :

\[
R_i = 
\sqrt{
\sum_{k=1}^{5}
\left(
\frac{M_k - E_{i,k}}{\sigma_k}
\right)^2
}
\]

o√π :
- $M_k$ est la valeur mesur√©e pour le rapport √©l√©mentaire $k$,
- $E_{i,k}$ la valeur correspondante issue de l‚Äôexp√©rience $i$,
- $\sigma_k$ l‚Äôincertitude associ√©e √† la mesure $M_k$.

---

### S√©lection de la condition optimale

Le **r√©sidu minimal** est d√©fini par :

\[
R_{\min}(x, y) = \min_i R_i(x, y)
\]

L‚Äôexp√©rience $E_i$ associ√©e √† $R_{\min}$ correspond √† la **condition exp√©rimentale la plus proche**, d‚Äôo√π l‚Äôon d√©duit :
 
- la **pression de fusion partielle** correspondante,
- le **taux de fusion partielle $F$** associ√©.

Cette minimisation est effectu√©e **pour chaque pixel valide** de la carte de Mercure.

---

### Cartes pond√©r√©es de pression et de fusion

Deux matrices globales sont ainsi g√©n√©r√©es :

- **`pressure_map`** : carte de la **pression de fusion partielle la plus probable** (en GPa)  
- **`fusion_map`** : carte du **taux de fusion partielle correspondant** (en %)

Ces cartes sont affich√©es sous forme d‚Äôimages color√©es (`image()`),  
avec :
- l‚Äôaxe des **abscisses = longitude**,
- l‚Äôaxe des **ordonn√©es = latitude**.

Les r√©sultats sont ensuite sauvegard√©s pour r√©utilisation dans les √©tapes suivantes du projet :




```{r}
# ==================== CALCUL DES CARTES DE PRESSION ET DE FUSION ====================
maps <- list(
  MgSi     = get_layer_as_matrix(result_array_full, 24),
  MgSi_err = get_layer_as_matrix(result_array_full, 25),
  AlSi     = get_layer_as_matrix(result_array_full, 15),
  AlSi_err = get_layer_as_matrix(result_array_full, 16),
  CaSi     = get_layer_as_matrix(result_array_full, 17),
  CaSi_err = get_layer_as_matrix(result_array_full, 18),
  FeSi     = get_layer_as_matrix(result_array_full, 21),
  FeSi_err = get_layer_as_matrix(result_array_full, 22),
  SSi      = get_layer_as_matrix(result_array_full, 26),
  SSi_err  = get_layer_as_matrix(result_array_full, 27)
)

nx <- nrow(maps$MgSi)
ny <- ncol(maps$MgSi)


pressure_map <- matrix(NA, nrow = nx, ncol = ny)
fusion_map   <- matrix(NA, nrow = nx, ncol = ny)

compute_residual <- function(M, sigma, E) {
  valid <- !is.na(M) & !is.na(sigma)
  if (sum(valid) < 3) return(NA)
  sqrt(sum(((M[valid] - E[valid]) / sigma[valid])^2))
}




for (x in 1:nx) {
  for (y in 1:ny) {
    M <- c(maps$MgSi[x,y], maps$AlSi[x,y], maps$CaSi[x,y],
           maps$FeSi[x,y], maps$SSi[x,y])
    sigma <- c(maps$MgSi_err[x,y], maps$AlSi_err[x,y], maps$CaSi_err[x,y],
               maps$FeSi_err[x,y], maps$SSi_err[x,y])
    if (all(is.na(M))) next
    
    residuals <- apply(exp_data[, c("Mg/Si","Al/Si","Ca/Si","Fe/Si","S/Si")], 1, function(E){
      compute_residual(M, sigma, E)
    })
    
    best_index <- which.min(residuals)
    if (is.na(best_index)) next
    
    pressure_map[x,y] <- exp_data$Pression[best_index]
    fusion_map[x,y]   <- exp_data$F[best_index]
  }
}


lst <- list(
  pressure_map = pressure_map,
  fusion_map = fusion_map
)

for (name in lst) {
  image(
    z = t(apply(name, 2, rev)),   
    col = terrain.colors(100),
    main = "",
    axes = T,
    xlab = "Longitude",
    ylab = "Latitude"
    
  )}

saveRDS(pressure_map, file.path(base_path, "pressure_map_masked_weighted.rds"))
saveRDS(fusion_map,   file.path(base_path, "fusion_map_masked_weighted.rds"))


```



# R√©f√©rences

<a id="nittler2020"></a>
Nittler, L.R., Frank, E.A., Weider, S.Z., Crapster-Pregont, E., Vorburger, A., Starr, R.D. &
Solomon, S.C., 2020. global major-element maps of Mercury from four years of MESSENGER
X-Ray Spectrometer observations. Icarus, 345, 113716. https://doi.org/10.1016/j.icarus.2020.113716.



