---
title: "Analyse g√©ocimique de la surface de Mercure √† partir des donn√©es MESSENGER"
author: "Alexandre Michaux & Beniamino Orsini"
date: "`r Sys.Date()`"
output:
  html_document:
    css: "retro.css"
    toc: true
    toc_float: true
    number_sections: true
    code_folding: hide   # <-- code cach√© par d√©faut, bouton pour afficher
    df_print: paged
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  echo = FALSE,
  eval = T,
  fig.align = "center",
  fig.width = 7,
  fig.height = 5
)
```

# Pr√©sentation du projet

Ce projet s‚Äôinscrit dans le cadre du module d‚Äôanalyse de donn√©es et vise √† √©tudier la **composition g√©ochimique de la surface de Mercure** √† partir des donn√©es orbitales issues de la mission **MESSENGER**.  
L‚Äôobjectif global est de relier les **h√©t√©rog√©n√©it√©s chimiques de surface** √† l‚Äô**histoire magmatique** et √† l‚Äô**√©volution interne** de la plan√®te.

## La mission MESSENGER

La mission *MESSENGER (MErcury Surface, Space ENvironment, GEochemistry, and Ranging)*, lanc√©e par la NASA en 2004 et mise en orbite autour de Mercure en mars 2011, a fourni jusqu‚Äô√† 2015 un ensemble complet de donn√©es sur la g√©ochimie, la topographie et le champ magn√©tique de la plan√®te.  
Les donn√©es utilis√©es ici proviennent principalement de deux instruments :

- **XRS (X-Ray Spectrometer)** : mesure des rapports √©l√©mentaires de surface (Mg/Si, Al/Si, Ca/Si, Fe/Si, S/Si).  
- **MLA (Mercury Laser Altimeter)** : mesure de la topographie et de l‚Äôaltitude absolue des terrains.

Ces informations permettent de produire des **cartes globales de composition chimique**, repr√©sentatives des terrains volcaniques et de l‚Äô√©volution du manteau mercurien.

Les donn√©es utilis√©es dans ce projet proviennent principalement de l‚Äôinstrument XRS (X-Ray Spectrometer) pour la g√©ochimie et de l‚Äôinstrument MLA (Mercury Laser Altimeter) pour la topographie fournie par la publication de [Nittler *et al.* (2020)](#nittler2020).
	
## Objectifs du projet

Le but de ce travail est double :

1. **Consolider les donn√©es MESSENGER** pour obtenir un cube global (latitude √ó longitude √ó variable) repr√©sentant les principaux rapports g√©ochimiques de la surface de Mercure.
2. **Comparer ces compositions orbitales** √† des **exp√©riences de fusion partielle** r√©alis√©es en laboratoire (s√©ries Mer8 et Mer15) afin d‚Äôen d√©duire des **cartes globales de pression de fusion** et de **taux de fusion partielle (F)**.
3. Etablir un jeu de donn√©es statistiques et cartographiques complet, permettant d‚Äô√©tudier les relations entre composition chimique, topographie.

Cette approche permet de relier chaque pixel de la surface mercurienne √† des conditions exp√©rimentales de fusion, et donc √† des profondeurs ou degr√©s de fusion du manteau.

# Pr√©paration et traitement des donn√©es

Les donn√©es brutes sont constitu√©es de plusieurs fichiers de formats vari√©s (`.bmp`, `.png`, `.dat`, `.rds`), chacun repr√©sentant une variable g√©ochimique ou g√©ophysique.  
Avant toute analyse, ces couches sont **uniformis√©es** et **empil√©es** dans un **cube tridimensionnel** (latitude √ó longitude √ó variable).  
Chaque couche correspond √† une carte globale : par exemple, les rapports **Mg/Si**, **Al/Si**, **Ca/Si**, **Fe/Si** et **S/Si**.

Les √©tapes principales sont les suivantes :

1. **Chargement automatique** des fichiers pr√©sents dans le dossier `data/`, avec lecture adapt√©e selon le format.  
2. **Application de facteurs de correction** pour convertir les intensit√©s (valeurs 0‚Äì255 des BMP/PNG) en valeurs normalis√©es de rapport √©l√©mentaire.  
3. **Redimensionnement** de toutes les couches √† une grille uniforme de **720 √ó 1440 pixels** (r√©solution latitude‚Äìlongitude).  
4. **Cr√©ation d‚Äôun masque commun** √©liminant les pixels invalides (valeurs nulles ou < 0.0001).  
5. **Empilement final** des couches corrig√©es et masqu√©es dans un objet 3D `result_array_full`, sauvegard√© au format `.rds`.

Le code effectue ensuite un contr√¥le statistique du cube (nombre de pixels valides, distribution des valeurs) et permet une visualisation rapide de chaque couche via la fonction `image()`, dont le titre correspond automatiquement au nom du fichier source.





```{r}
rm(list=ls())

# ==================== PACKAGES ====================
packages <- c("raster","bmp","png","rstudioapi","abind","plotly")
installed_packages <- packages %in% installed.packages()[,"Package"]
if (any(!installed_packages)) install.packages(packages[!installed_packages])
lapply(packages, library, character.only = TRUE)

# ==================== CHEMINS ====================
base_path <- dirname(rstudioapi::getSourceEditorContext()$path)
directory_path <- file.path(base_path, "data")
result_file <- file.path(base_path, "result_array_with_uncertainty.rds")

# ==================== UTILS ====================
from03602180 <- function(mat) {
  middle <- dim(mat)[2] / 2
  cbind(mat[, (middle + 1):(2 * middle)], mat[, 1:middle])
}

resize_to_target <- function(mat, target_dim = c(720,1440)) {
  if (is.null(dim(mat))) stop("Matrix has no dimensions.")
  if (all(dim(mat) == target_dim)) return(mat)
  r <- raster::raster(mat)
  r_target <- raster::raster(nrows = target_dim[1], ncols = target_dim[2])
  r_resized <- raster::resample(r, r_target, method = "bilinear")
  as.matrix(r_resized)
}

# ==================== FONCTION DE LECTURE DES COUCHES ====================
process_files_to_3d_array <- function(directory_path, correction_factors = NULL, target_dim = c(720, 1440)) {
  # -------------------------------------------------------
  # Charge BMP / PNG / DAT / RDS d'un dossier,
  # applique une √©ventuelle correction par fichier,
  # redimensionne √† target_dim et empile en tableau 3D.
  # (CSV exclus, tous les RDS inclus)
  # -------------------------------------------------------
  
  # Liste des fichiers, en excluant explicitement CSV et TIFF
  file_list <- list.files(directory_path, full.names = TRUE)
  file_list <- file_list[!grepl("\\.csv$", file_list, ignore.case = TRUE)]
  file_list <- file_list[!grepl("\\.tif(f)?$", file_list, ignore.case = TRUE)]
  # Ne garder que les extensions g√©r√©es
  file_list <- file_list[grepl("\\.(bmp|png|dat|rds)$", file_list, ignore.case = TRUE)]
  
  n_files <- length(file_list)
  if (n_files == 0) stop("Aucun fichier pris en charge (BMP/PNG/DAT/RDS) dans : ", directory_path)
  
  layer_names <- basename(file_list)
  array_3d <- array(NA_real_, dim = c(target_dim[1], target_dim[2], n_files))
  
  apply_correction <- function(m, cf) {
    if (is.null(cf)) return(m)
    m * cf
  }
  
  for (i in seq_along(file_list)) {
    file_path <- file_list[i]
    file_name <- layer_names[i]
    ext <- tolower(tools::file_ext(file_name))
    message("‚Üí Lecture de ", file_name)
    
    if (ext == "bmp") {
      # BMP : lecture brute, orientation inchang√©e
      m <- read.bmp(file_path)
      mode(m) <- "numeric"
      m <- apply_correction(m, correction_factors[[file_name]])
      m <- resize_to_target(m, target_dim)
      array_3d[,,i] <- m
      
    } else if (ext == "png") {
      # PNG : via raster -> matrice ; flip vertical pour redresser
      m <- as.matrix(raster::raster(file_path))
      mode(m) <- "numeric"
      m <- apply_correction(m, correction_factors[[file_name]])
      m <- resize_to_target(m, target_dim)
      m <- m[nrow(m):1, ]  # redressement vertical
      array_3d[,,i] <- m
      
    } else if (ext == "dat") {
      # DAT : structure sp√©ciale -> recollage + (dans ta version) inversion L/C
      m <- from03602180(as.matrix(read.table(file_path, header = FALSE)))
      mode(m) <- "numeric"
      m <- apply_correction(m, correction_factors[[file_name]])
      m <- resize_to_target(m, target_dim)
      array_3d[,,i] <- m
      
    } else if (ext == "rds") {
      # RDS : on prend TOUT fichier .rds
      m <- readRDS(file_path)
      mode(m) <- "numeric"
      m <- apply_correction(m, correction_factors[[file_name]])
      m <- resize_to_target(m, target_dim)
      array_3d[,,i] <- m
      
    } else {
      warning("‚ö†Ô∏è Type non support√©/ignor√© : ", file_name)
      next
    }
  }
  
  attr(array_3d, "layer_names") <- layer_names
  array_3d
}
# ==================== FACTEURS DE CORRECTION ====================
correction_factors <- list(
  "mgsi.bmp"    = 0.860023 / 255.0,
  "alsi.bmp"    = 0.402477 / 255.0,
  "ssi.bmp"     = 0.161680 / 255.0,
  "fesi.bmp"    = 0.117737 / 255.0,
  "casi.bmp"    = 0.318000 / 255.0,
  "mgsierr.png" = 0.223226 / 255.0,
  "alsierr.png" = 0.153596 / 255.0,
  "ssierr.png"  = 0.0398775 / 255.0,
  "fesierr.png" = 0.0283532 / 255.0,
  "casierr.png" = 0.0809775 / 255.0
)

# ==================== CONSTRUCTION DU CUBE ====================
result_array <- process_files_to_3d_array(directory_path, correction_factors)
layer_names  <- attr(result_array, "layer_names")
cat("‚úÖ Cube initial charg√© :", dim(result_array)[3], "couches\n")

# ==================== MASQUE COMMUN (5 RAPPORTS .bmp) ====================
idx_mgsi <- grep("^mgsi\\.bmp$", layer_names, ignore.case = TRUE)
idx_alsi <- grep("^alsi\\.bmp$", layer_names, ignore.case = TRUE)
idx_casi <- grep("^casi\\.bmp$", layer_names, ignore.case = TRUE)
idx_fesi <- grep("^fesi\\.bmp$", layer_names, ignore.case = TRUE)
idx_ssi  <- grep("^ssi\\.bmp$",  layer_names, ignore.case = TRUE)

if (any(lengths(list(idx_mgsi,idx_alsi,idx_casi,idx_fesi,idx_ssi)) == 0)) {
  stop("‚ùå Introuvable : au moins une des couches mgsi/alsi/casi/fesi/ssi (.bmp).")
}

# On consid√®re qu‚Äôune valeur < 0.0001 = pixel invalide
mask_common <- (result_array[,,idx_mgsi]  > 0.0001) &
  (result_array[,,idx_alsi]  > 0.0001) &
  (result_array[,,idx_casi]  > 0.0001) &
  (result_array[,,idx_fesi]  > 0.0001) &
  (result_array[,,idx_ssi]   > 0.0001)

# ==================== CUBE MASQU√â (NA sur pixels invalides) ====================
masked_cube <- array(NA_real_, dim = dim(result_array))
for (i in 1:dim(result_array)[3]) {
  L <- result_array[,,i]
  L[!mask_common] <- NA_real_
  masked_cube[,,i] <- L
}

# ==================== CONCAT√âNER : ORIGINAL + MASQU√â ====================
result_array_full <- abind::abind(result_array, masked_cube, along = 3)
attr(result_array_full, "layer_names") <- c(layer_names, paste0(layer_names, "_masked"))

cat("‚úÖ Cube final :", dim(result_array_full)[3], "couches (doubl√©)\n")

# ==================== STATISTIQUES DES COUCHES ====================
na_counts <- sapply(1:dim(result_array_full)[3], function(i) sum(is.na(result_array_full[,,i])))
layer_info <- data.frame(
  Index = seq_along(attr(result_array_full, "layer_names")),
  Layer = attr(result_array_full, "layer_names"),
  NA_Count = na_counts
)
cat("\n=== STATISTIQUES DES COUCHES ===\n")
print(layer_info)

# ==================== SAUVEGARDE ====================
saveRDS(result_array_full, file = result_file)
cat("\nüíæ Sauvegard√© :", result_file, "\n")

result_array_full[result_array_full == 0 | abs(result_array_full) < 1e-10] <- NA_real_
#nombre de NA dans chaque couche
na_counts <- sapply(1:dim(result_array_full)[3], function(i) sum(is.na(result_array_full[,,i])))
layer_info <- data.frame(Index = seq_along(attr(result_array_full, "layer_names")), Layer = attr(result_array_full, "layer_names"), NA_Count = na_counts)
print(layer_info) # Afficher les informations des couches avec le nombre de

```

La fonction ci-dessous permet d'extraire une matrice 2D (une couche) du tableau 3D en fonction de l'index de la couche et de potentiellement l'afficher.

```{r}
get_layer_as_matrix <- function(result_array, layer_index) {

  if (layer_index < 1 || layer_index > dim(result_array)[3]) { #check si l'index est inf. √† 1 (index minimum) ou si il est sup. au nombre de couche de result_array
    stop("Layer index out of bounds.")
  }
  return(result_array[,,layer_index])   # Extrait et retourne la couche sp√©cifi√©e sous forme de matrice
}

# Boucle d'affichage avec titre = nom du fichier
for (i in seq_along(layer_names)) {
  layer_matrix <- get_layer_as_matrix(result_array_full, i)
  
  image(
    z = t(apply(layer_matrix, 2, rev)),   # rotation correcte pour l'affichage
    col = terrain.colors(100),
    main = paste("Couche", i, "-", layer_names[i]),  # Titre avec nom de fichier
    axes = FALSE,
    xlab = "Longitude",
    ylab = "Latitude"
  )
}
```

## Int√©gration des donn√©es exp√©rimentales

Pour relier les compositions observ√©es √† la surface de Mercure √† des conditions physiques (pression, temp√©rature, taux de fusion partielle), deux jeux de donn√©es exp√©rimentales sont utilis√©s :

- **Mer8** et **Mer15**, correspondant √† deux compositions de d√©part diff√©rentes du manteau mercurien.  
  Ces exp√©riences de fusion partielle ont √©t√© conduites √† des pressions de **1.5, 3 et 5 GPa** et des temp√©ratures comprises entre **1475¬∞C et 1700¬∞C**.

Chaque ligne de ces fichiers (`data_Mer8.csv`, `data_Mer15.csv`) contient :
- la pression exp√©rimentale,
- le taux de fusion partielle (F),
- et les rapports chimiques correspondants (Mg/Si, Al/Si, Ca/Si, Fe/Si, S/Si).

Les deux s√©ries sont combin√©es pour constituer un ensemble de r√©f√©rence unique (`exp_data`), utilis√© pour comparer les compositions de surface pixel par pixel.

```{r}
mer8_path  <- "/Users/alexandremichaux/Documents/UCA/Cours/Analyse des donneÃÅes/TP/TPs/Projet final/data/data_Mer8.csv"
mer15_path <- "/Users/alexandremichaux/Documents/UCA/Cours/Analyse des donneÃÅes/TP/TPs/Projet final/data/data_Mer15.csv"

data_Mer8  <- read.csv(mer8_path,  sep = ",", header = TRUE, check.names = FALSE, stringsAsFactors = FALSE)
data_Mer15 <- read.csv(mer15_path, sep = ",", header = TRUE, check.names = FALSE, stringsAsFactors = FALSE)

# Combiner les deux jeux exp√©rimentaux
exp_data <- rbind(data_Mer8, data_Mer15)
exp_data <- exp_data[complete.cases(exp_data[, c("Mg/Si","Al/Si","Ca/Si","Fe/Si","S/Si")]), ]
```


## M√©thode de corr√©lation g√©ochimique

L‚Äôobjectif est d‚Äôassocier chaque pixel de Mercure √† la **condition exp√©rimentale la plus proche** parmi les donn√©es Mer8/Mer15.  
Pour cela, on calcule pour chaque pixel un **r√©sidu pond√©r√©** mesurant la diff√©rence entre la composition observ√©e et la composition exp√©rimentale.

---

### Calcul du r√©sidu pond√©r√©

Pour chaque pixel $(x, y)$, on d√©finit un **vecteur de mesures** :

\[
\mathbf{M}(x, y) = 
\begin{pmatrix}
\mathrm{Mg/Si} \\
\mathrm{Al/Si} \\
\mathrm{Ca/Si} \\
\mathrm{Fe/Si} \\
\mathrm{S/Si}
\end{pmatrix}
\]

et les **incertitudes correspondantes** :

\[
\boldsymbol{\sigma} = 
\begin{pmatrix}
\sigma_{\mathrm{Mg/Si}} \\
\sigma_{\mathrm{Al/Si}} \\
\sigma_{\mathrm{Ca/Si}} \\
\sigma_{\mathrm{Fe/Si}} \\
\sigma_{\mathrm{S/Si}}
\end{pmatrix}
\]

Pour chaque exp√©rience $E_i$ du jeu **Mer8/Mer15**, on calcule le **r√©sidu pond√©r√©** :

\[
R_i = 
\sqrt{
\sum_{k=1}^{5}
\left(
\frac{M_k - E_{i,k}}{\sigma_k}
\right)^2
}
\]

o√π :
- $M_k$ est la valeur mesur√©e pour le rapport √©l√©mentaire $k$,
- $E_{i,k}$ la valeur correspondante issue de l‚Äôexp√©rience $i$,
- $\sigma_k$ l‚Äôincertitude associ√©e √† la mesure $M_k$.

---

### S√©lection de la condition optimale

Le **r√©sidu minimal** est d√©fini par :

\[
R_{\min}(x, y) = \min_i R_i(x, y)
\]

L‚Äôexp√©rience $E_i$ associ√©e √† $R_{\min}$ correspond √† la **condition exp√©rimentale la plus proche**, d‚Äôo√π l‚Äôon d√©duit :
 
- la **pression de fusion partielle** correspondante,
- le **taux de fusion partielle $F$** associ√©.

Cette minimisation est effectu√©e **pour chaque pixel valide** de la carte de Mercure.

---

### Cartes pond√©r√©es de pression et de fusion

Deux matrices globales sont ainsi g√©n√©r√©es :

- **`pressure_map`** : carte de la **pression de fusion partielle la plus probable** (en GPa)  
- **`fusion_map`** : carte du **taux de fusion partielle correspondant** (en %)

Ces cartes sont affich√©es sous forme d‚Äôimages color√©es (`image()`),  
avec :
- l‚Äôaxe des **abscisses = longitude**,
- l‚Äôaxe des **ordonn√©es = latitude**.

Les r√©sultats sont ensuite sauvegard√©s pour r√©utilisation dans les √©tapes suivantes du projet :




```{r}
# ==================== CALCUL DES CARTES DE PRESSION ET DE FUSION ====================
library(plotly)

# --- 1. Chargement des donn√©es exp√©rimentales Mer8 et Mer15 ---
mer8_path  <- "/Users/alexandremichaux/Documents/UCA/Cours/Analyse des donneÃÅes/TP/TPs/Projet final/data/data_Mer8.csv"
mer15_path <- "/Users/alexandremichaux/Documents/UCA/Cours/Analyse des donneÃÅes/TP/TPs/Projet final/data/data_Mer15.csv"

data_Mer8  <- read.csv(mer8_path,  sep = ",", header = TRUE, check.names = FALSE, stringsAsFactors = FALSE)
data_Mer15 <- read.csv(mer15_path, sep = ",", header = TRUE, check.names = FALSE, stringsAsFactors = FALSE)

data_Mer8  <- data_Mer8 [complete.cases(data_Mer8 [,  c("Mg/Si","Al/Si","Ca/Si","Fe/Si","S/Si")]), ]
data_Mer15 <- data_Mer15[complete.cases(data_Mer15[, c("Mg/Si","Al/Si","Ca/Si","Fe/Si","S/Si")]), ]

# --- 2. Extraction des couches masqu√©es depuis result_array_full ---
maps <- list(
  MgSi     = get_layer_as_matrix(result_array_full, 24),
  MgSi_err = get_layer_as_matrix(result_array_full, 25),
  AlSi     = get_layer_as_matrix(result_array_full, 15),
  AlSi_err = get_layer_as_matrix(result_array_full, 16),
  CaSi     = get_layer_as_matrix(result_array_full, 17),
  CaSi_err = get_layer_as_matrix(result_array_full, 18),
  FeSi     = get_layer_as_matrix(result_array_full, 21),
  FeSi_err = get_layer_as_matrix(result_array_full, 22),
  SSi      = get_layer_as_matrix(result_array_full, 26),
  SSi_err  = get_layer_as_matrix(result_array_full, 27)
)

nx <- nrow(maps$MgSi)
ny <- ncol(maps$MgSi)

# --- 3. Fonction de calcul du r√©sidu pond√©r√© ---
compute_residual <- function(M, sigma, E) {
  valid <- !is.na(M) & !is.na(sigma)
  if (sum(valid) < 3) return(NA)
  sqrt(sum(((M[valid] - E[valid]) / sigma[valid])^2))
}

# --- 4. Fonction g√©n√©rique pour cr√©er les cartes Pression/Fusion ---
make_maps <- function(exp_data, label) {
  pressure_map <- matrix(NA, nrow = nx, ncol = ny)
  fusion_map   <- matrix(NA, nrow = nx, ncol = ny)
  
  pb <- txtProgressBar(min = 0, max = nx, style = 3)
  for (x in 1:nx) {
    for (y in 1:ny) {
      M <- c(maps$MgSi[x,y], maps$AlSi[x,y], maps$CaSi[x,y],
             maps$FeSi[x,y], maps$SSi[x,y])
      sigma <- c(maps$MgSi_err[x,y], maps$AlSi_err[x,y], maps$CaSi_err[x,y],
                 maps$FeSi_err[x,y], maps$SSi_err[x,y])
      if (all(is.na(M))) next
      
      residuals <- apply(exp_data[, c("Mg/Si","Al/Si","Ca/Si","Fe/Si","S/Si")], 1, function(E){
        compute_residual(M, sigma, E)
      })
      
      best_index <- which.min(residuals)
      if (is.na(best_index)) next
      
      pressure_map[x,y] <- exp_data$Pression[best_index]
      fusion_map[x,y]   <- exp_data$F[best_index]
    }
    setTxtProgressBar(pb, x)
  }
  close(pb)
  cat("\n‚úÖ Calcul termin√© pour", label, "\n")
  list(pressure = pressure_map, fusion = fusion_map)
}

# --- 5. Ex√©cution pour chaque jeu exp√©rimental ---
maps_Mer8  <- make_maps(data_Mer8,  "Mer8")
maps_Mer15 <- make_maps(data_Mer15, "Mer15")

# --- 6. Sauvegarde des cartes (facultatif mais conseill√©) ---
saveRDS(maps_Mer8$pressure,  file.path(base_path, "pressure_map_Mer8.rds"))
saveRDS(maps_Mer8$fusion,    file.path(base_path, "fusion_map_Mer8.rds"))
saveRDS(maps_Mer15$pressure, file.path(base_path, "pressure_map_Mer15.rds"))
saveRDS(maps_Mer15$fusion,   file.path(base_path, "fusion_map_Mer15.rds"))

# --- 7. Ajout des 4 cartes au cube principal ---
result_array_full <- abind::abind(
  result_array_full,
  maps_Mer8$pressure,
  maps_Mer8$fusion,
  maps_Mer15$pressure,
  maps_Mer15$fusion,
  along = 3
)

# Mise √† jour des noms des couches
attr(result_array_full, "layer_names") <- c(
  attr(result_array_full, "layer_names"),
  "pressure_Mer8", "fusion_Mer8", "pressure_Mer15", "fusion_Mer15"
)

# --- 8. Sauvegarde du cube complet ---
saveRDS(result_array_full, file = result_file)
cat("\nüíæ Cube 3D mis √† jour avec les cartes Mer8/Mer15 :", dim(result_array_full)[3], "couches.\n")

# --- 9. V√©rification rapide ---
layer_info <- data.frame(
  Index = seq_along(attr(result_array_full, "layer_names")),
  Layer = attr(result_array_full, "layer_names")
)
print(tail(layer_info, 8))


# Exemple d‚Äôextraction
pressure_Mer8  <- get_layer_as_matrix(result_array_full,29)
fusion_Mer8    <- get_layer_as_matrix(result_array_full,30)
pressure_Mer15 <- get_layer_as_matrix(result_array_full, 31)
fusion_Mer15   <- get_layer_as_matrix(result_array_full, 32)


# Titres √† afficher pour chaque couche
titles <- c("pressure_Mer8", "fusion_Mer8", "pressure_Mer15", "fusion_Mer15")

# Boucle sur les indices correspondants
for (i in 1:4) {
  L <- get_layer_as_matrix(result_array_full, 28 + i)  # 29 ‚Üí 32
  
  image(
    z = t(apply(L, 2, rev)),      # rotation correcte pour affichage
    main = titles[i],             # titre personnalis√©
    col = terrain.colors(100),
    axes = TRUE,
    xlab = "Longitude",
    ylab = "Latitude"
  )
}

```
Afin d‚Äô√©valuer la dispersion et la pr√©cision des rapports g√©ochimiques mesur√©s par MESSENGER, on r√©alise une analyse statistique globale des cinq rapports √©l√©mentaires (Mg/Si, Al/Si, Ca/Si, Fe/Si, S/Si).

Chaque distribution est repr√©sent√©e par un boxplot indiquant la variabilit√© spatiale des valeurs mesur√©es √† la surface de Mercure.
Les barres d‚Äôerreur superpos√©es repr√©sentent les incertitudes moyennes ¬±1œÉ issues des cartes d‚Äôerreur correspondantes.

Cette visualisation permet de comparer directement la stabilit√© relative de chaque rapport ainsi que le niveau de bruit instrumental affectant les mesures.
```{r}
# ==================== BOXPLOTS CLASSIQUES + INCERTITUDES SUPERPOS√âES ====================

# --- 1. Donn√©es √† partir de ton objet maps ---
ratios <- c("MgSi", "AlSi", "CaSi", "FeSi", "SSi")

df <- do.call(rbind, lapply(ratios, function(r) {
  vals <- as.vector(maps[[r]])
  errs <- as.vector(maps[[paste0(r, "_err")]])
  data.frame(
    Ratio = r,
    Value = vals,
    Error = errs
  )
}))

df <- df[complete.cases(df), ]

# --- 2. Calcul de statistiques par rapport ---
library(dplyr)
err_summary <- df %>%
  group_by(Ratio) %>%
  summarise(
    mean_val = mean(Value, na.rm = TRUE),
    mean_err = mean(Error, na.rm = TRUE),
    sd_err   = sd(Error, na.rm = TRUE)
  )

# --- 3. Couleurs pour les boxplots et les symboles d‚Äôerreur ---
cols_box <- c("darkorange", "steelblue", "seagreen3", "indianred3", "goldenrod")
cols_err <- c("chocolate3", "navy", "forestgreen", "darkred", "darkgoldenrod4")

# --- 4. Trac√© des boxplots normaux ---
boxplot(Value ~ Ratio, data = df,
        col = cols_box,
        border = "gray30",
        ylab = "Rapport √©l√©mentaire (X/Si)",
        main = "Distribution des rapports √©l√©mentaires avec incertitudes",
        outline = FALSE,
        las = 1,
        cex.axis = 0.9)

# --- 5. Superposition des incertitudes moyennes (autre couleur / symbole) ---
# Positions x des boxplots (1:5)
xpos <- 1:length(ratios)

# Points = moyennes, barres = ¬± √©cart-type des erreurs
points(xpos, err_summary$mean_val, 
       pch = 21, bg = "white", col = "black", cex = 1.3, lwd = 1.5)
arrows(xpos,
       err_summary$mean_val - err_summary$mean_err,
       xpos,
       err_summary$mean_val + err_summary$mean_err,
       angle = 90, code = 3, length = 0.08, lwd = 2, col = cols_err)

# --- 6. L√©gende claire ---
legend("topleft",
       legend = c("Distribution (boxplot)", "Incertitude moyenne ¬±1œÉ(err)"),
       pch = c(15, 21),
       pt.bg = c(cols_box[1], "white"),
       col = c("gray30", "black"),
       lwd = c(0, 2),
       pt.cex = c(1.8, 1.3),
       bty = "n")
```
Pour comprendre comment la composition varie selon les provinces g√©ologiques, on compare ici la distribution r√©gionale et la distribution globale de chaque rapport √©l√©mentaire.

Les courbes sup√©rieures repr√©sentent les distributions propres √† chaque r√©gion (zones riches en magn√©sium, plaines riches en aluminium, bassin de Caloris, etc.), tandis que les courbes inf√©rieures indiquent la distribution globale de la plan√®te.

Cette approche met en √©vidence les contrastes g√©ochimiques r√©gionaux et permet d‚Äô√©valuer la variabilit√© intra-r√©gionale par rapport √† la composition moyenne de Mercure
```{r}
# ==================== DISTRIBUTIONS R√âGIONALES/GLOBALES ‚Äî L√âGENDE + HAUTEURS FIXES ====================

# --- Packages ---
if (!require(patchwork)) install.packages("patchwork")
library(ggplot2)
library(dplyr)
library(patchwork)

# --- 1. Donn√©es ---
maps <- list(
  MgSi = get_layer_as_matrix(result_array_full, 24),
  AlSi = get_layer_as_matrix(result_array_full, 15),
  CaSi = get_layer_as_matrix(result_array_full, 17),
  FeSi = get_layer_as_matrix(result_array_full, 21),
  SSi  = get_layer_as_matrix(result_array_full, 26)
)

region_map   <- get_layer_as_matrix(result_array_full, 28)
region_vals  <- c(1,2,3,4,5,6)
region_names <- c("High-Mg","Al-rich","Caloris","Rach","High-Al NVP","Low-Al NVP")
Region <- factor(as.vector(region_map), levels = region_vals, labels = region_names)

ratios <- names(maps)
df <- do.call(rbind, lapply(ratios, function(r){
  data.frame(Ratio = r, Value = as.vector(maps[[r]]), Region = Region)
})) |> na.omit()

# --- 2. Palette g√©ologique ---
cols_base <- c(
  "High-Mg"="#E4572E", "Al-rich"="#17BEBB", "Caloris"="#FFC914",
  "Rach"="#4B4E6D", "High-Al NVP"="#76B041", "Low-Al NVP"="#A23B72"
)

# --- 3. Fonction pour cr√©er les paires de graphiques ---
make_pair <- function(r, show_legend = FALSE){
  d  <- df[df$Ratio==r, ]
  xr <- range(d$Value, na.rm = TRUE)
  
  # Distribution r√©gionale
  p_reg <- ggplot(d, aes(Value, fill=Region, color=Region)) +
    geom_density(alpha=.35, linewidth=1, adjust=1.2) +
    scale_fill_manual(values=cols_base, name="R√©gions g√©ologiques") +
    scale_color_manual(values=cols_base, guide="none") +
    scale_x_continuous(limits = xr) +
    labs(title=paste("Distribution r√©gionale de", r), x=NULL, y="Densit√©") +
    theme_minimal(base_size=12) +
    theme(
      plot.title = element_text(face="bold", hjust=.5),
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      panel.grid.minor = element_blank(),
      legend.position = if (show_legend) "bottom" else "none"
    )
  
  # Distribution globale
  p_glb <- ggplot(d, aes(Value)) +
    geom_density(fill="#CCCCCC", color="#444444", alpha=.6, linewidth=1.1, adjust=1.2) +
    scale_x_continuous(limits = xr) +
    labs(title=paste("Distribution globale de", r), x=r, y="Densit√©") +
    theme_minimal(base_size=12) +
    theme(
      plot.title = element_text(face="bold", hjust=.5),
      panel.grid.minor = element_blank(),
      legend.position = "none"
    )
  
  # Empilement vertical (hauteurs √©gales)
  p_reg / p_glb + plot_layout(heights = c(1, 1))
}

# --- 4. Cr√©ation des 5 couples (on garde la l√©gende sur le dernier) ---
pairs <- list(
  make_pair("MgSi"),
  make_pair("AlSi"),
  make_pair("CaSi"),
  make_pair("FeSi"),
  make_pair("SSi", show_legend = TRUE)  # l√©gende visible ici
)

# --- 5. Combinaison : 3 couples √† gauche, 2 √† droite ---
left_block  <- wrap_plots(pairs[1:3], ncol = 1, heights = rep(1, 3))
right_block <- wrap_plots(pairs[4:5], ncol = 1, heights = rep(1, 2))

# --- 6. Assemblage global + l√©gende commune ---
final_layout <- (left_block | right_block) +
  plot_layout(widths = c(3, 2), guides = "collect") &
  theme(
    legend.position = "bottom",
    legend.justification = "right",
    legend.text = element_text(size = 10),
    legend.title = element_text(face = "bold")
  )

# --- 7. Affichage final ---
final_layout

# --- Option : Export haute qualit√© ---
# ggsave("distributions_region_global_hauteur_legende.png", final_layout, width = 16, height = 10, dpi = 300)

```
Les graphiques suivants d√©taillent les distributions de densit√© des cinq rapports √©l√©mentaires pour chacune des r√©gions g√©ologiques majeures identifi√©es √† la surface de Mercure.

Chaque couleur correspond √† une r√©gion sp√©cifique (High-Mg, Al-rich, Caloris, Rach, High-Al NVP, Low-Al NVP).

Ces distributions permettent de quantifier les diff√©rences chimiques entre provinces, notamment la richesse relative en √©l√©ments alcalins, ferromagn√©siens ou sulfur√©s, et d‚Äôidentifier les tendances g√©ochimiques caract√©ristiques de chaque domaine morphologique.
```{r}
# ==================== COURBES DE DENSIT√â PAR R√âGION (avec noms g√©ologiques et couleurs harmonieuses) ====================

# --- 1. Extraction des couches g√©ochimiques ---
maps <- list(
  MgSi = get_layer_as_matrix(result_array_full, 24),
  AlSi = get_layer_as_matrix(result_array_full, 15),
  CaSi = get_layer_as_matrix(result_array_full, 17),
  FeSi = get_layer_as_matrix(result_array_full, 21),
  SSi = get_layer_as_matrix(result_array_full, 26)
)

# --- 2. Extraction de la carte des r√©gions ---
region_map <- get_layer_as_matrix(result_array_full, 28)
region_vec <- as.vector(region_map)

# --- 3. D√©finition des correspondances index ‚Üí noms ---
region_values <- c(1, 2, 3, 4, 5, 6)
region_names  <- c("High-Mg", "Al-rich", "Caloris", "Rach", "High-Al NVP", "Low-Al NVP")

# --- 4. Conversion des codes r√©gionaux en labels texte ---
region_factor <- factor(region_vec,
                        levels = region_values,
                        labels = region_names)
# (les 0 ou NA deviennent NA = pas de r√©gion)

# --- 5. Construction du data.frame pour toutes les cartes ---
ratios <- names(maps)
df <- do.call(rbind, lapply(ratios, function(r) {
  vals <- as.vector(maps[[r]])
  data.frame(
    Ratio = r,
    Value = vals,
    Region = region_factor
  )
}))
df <- df[complete.cases(df), ]

# --- 6. Palette am√©lior√©e et harmonieuse ---
# Palette inspir√©e de cartographies g√©ologiques (couleurs naturelles)
cols_base <- c(
  "#E4572E",  # orange chaud - High-Mg
  "#17BEBB",  # turquoise - Al-rich
  "#FFC914",  # jaune dor√© - Caloris
  "#4B4E6D",  # bleu-gris profond - Rach
  "#76B041",  # vert clair - High-Al NVP
  "#A23B72"   # magenta - Low-Al NVP
)

# Application d'une transparence douce
cols <- adjustcolor(cols_base, alpha.f = 0.4)

# --- 7. Liste finale des r√©gions pr√©sentes ---
region_levels <- levels(na.omit(df$Region))
n_regions <- length(region_levels)

# --- 8. Trac√© des densit√©s superpos√©es ---
par(mfrow = c(3, 2), mar = c(4,4,2,1))  # disposition 3x2 plots

for (r in ratios) {
  sub <- df[df$Ratio == r, ]
  
  # Calcul des limites pour x et y
  xlim <- range(sub$Value, na.rm = TRUE)
  d_all <- lapply(region_levels, function(reg) density(sub$Value[sub$Region == reg], na.rm = TRUE))
  ylim <- c(0, max(sapply(d_all, function(d) max(d$y, na.rm = TRUE))) * 1.1)
  
  # Plot vide
  plot(0, type = "n", xlim = xlim, ylim = ylim,
       xlab = r, ylab = "Densit√©",
       main = paste("Distribution par r√©gion -", r))
  
  # Boucle sur les r√©gions
  for (i in seq_along(region_levels)) {
    reg <- region_levels[i]
    vals <- sub$Value[sub$Region == reg]
    if (length(vals) < 20) next  # ignore r√©gions trop petites
    d <- density(vals, na.rm = TRUE)
    polygon(d, col = cols[i], border = adjustcolor(cols_base[i], alpha.f = 0.9), lwd = 1.5)
  }
  
  # L√©gende
  legend("topright",
         legend = region_levels,
         fill = cols_base,
         border = "gray20",
         bty = "n",
         cex = 0.8,
         title = "R√©gions g√©ologiques")
}

# --- Fin ---
cat("\n‚úÖ Graphiques de densit√© par r√©gion trac√©s avec succ√®s.\n")
```

Pour visualiser spatialement les √©carts √† la moyenne globale, on calcule pour chaque rapport un score normalis√© (Z-score) :
Z = \frac{X - \mu}{\sigma}

o√π X est la valeur du pixel, \mu la moyenne plan√©taire et \sigma l‚Äô√©cart-type.
Les cartes obtenues repr√©sentent les anomalies relatives (en unit√©s d‚Äô√©cart-type) :
les zones rouges indiquent des exc√®s par rapport √† la moyenne, les zones bleues des d√©ficits.

Ce traitement permet de rep√©rer clairement les domaines enrichis ou appauvris en chaque √©l√©ment, en lien avec les grands ensembles g√©ologiques (Caloris, plaines volcaniques, hauts plateaux, etc.).

```{r}
# ==================== CARTES D'ANOMALIES NORMALIS√âES (ggplot2 + grille 60¬∞/30¬∞) ====================

library(ggplot2)
library(dplyr)
library(tidyr)
library(grid)  # pour unit()

# 1) Extraire les couches
ratios <- list(
  MgSi = get_layer_as_matrix(result_array_full, 24),
  AlSi = get_layer_as_matrix(result_array_full, 15),
  CaSi = get_layer_as_matrix(result_array_full, 17),
  FeSi = get_layer_as_matrix(result_array_full, 21),
  SSi = get_layer_as_matrix(result_array_full, 26)
)

nx <- nrow(ratios$MgSi); ny <- ncol(ratios$MgSi)
lon <- seq(-180, 180, length.out = ny)
lat <- seq(  90, -90, length.out = nx)

to_df <- function(mat, name){
  M  <- t(mat)                              # transpos√©e pour bonne orientation
  mu <- mean(M, na.rm = TRUE)
  sdv <- sd(M, na.rm = TRUE)
  Z  <- (M - mu) / sdv
  Z[Z >  3] <-  3
  Z[Z < -3] <- -3
  expand.grid(Lon = lon, Lat = lat) |>
    mutate(Value = as.vector(Z), Ratio = name)
}

df_all <- do.call(rbind, lapply(names(ratios), \(r) to_df(ratios[[r]], r)))
df_all <- df_all[complete.cases(df_all), ]

# 2) Lignes de grille (60¬∞ lon / 30¬∞ lat)
grid_long <- seq(-180, 180, by = 60)
grid_lat  <- seq( -90,  90, by = 30)

grid_lon_df <- do.call(rbind, lapply(grid_long, \(L) data.frame(Lon = L,   Lat = lat, type = "lon")))
grid_lat_df <- do.call(rbind, lapply(grid_lat,  \(B) data.frame(Lon = lon, Lat = B,   type = "lat")))
grid_lines  <- rbind(grid_lon_df, grid_lat_df)

# 3) Palette
pal <- c("#08306B","#2171B5","#DEEBF7","#FEE0D2","#CB181D","#67000D")

# 4) Plot
ggplot(df_all, aes(Lon, Lat, fill = Value)) +
  geom_raster(interpolate = TRUE) +
  # grilles PAR-DESSUS, sans h√©riter des aes du raster
  geom_path(
    data = grid_lines[grid_lines$type == "lon", ],
    aes(x = Lon, y = Lat, group = Lon),
    inherit.aes = FALSE, color = "gray35", linewidth = 0.35, alpha = 0.9
  ) +
  geom_path(
    data = grid_lines[grid_lines$type == "lat", ],
    aes(x = Lon, y = Lat, group = Lat),
    inherit.aes = FALSE, color = "gray35", linewidth = 0.35, alpha = 0.9
  ) +
  scale_fill_gradientn(
    colors = pal, limits = c(-3, 3), breaks = seq(-3, 3, 1),
    name = "Z-score", oob = scales::squish
  ) +
  scale_x_continuous(breaks = grid_long) +
  scale_y_continuous(breaks = grid_lat) +
  coord_equal(xlim = c(-180, 180), ylim = c(-90, 90), expand = FALSE) +
  facet_wrap(~ Ratio, ncol = 3) +
  labs(title = "Cartes d‚Äôanomalies normalis√©es (Z-score)",
       x = "Longitude (¬∞)", y = "Latitude (¬∞)") +
  theme_minimal(base_size = 13) +
  theme(
    plot.title   = element_text(face = "bold", size = 16, hjust = 0.5),
    strip.text   = element_text(face = "bold", size = 13),
    axis.title   = element_text(face = "bold"),
    axis.text    = element_text(color = "gray20"),
    panel.grid   = element_blank(),                 # on g√®re la grille nous-m√™mes
    panel.border = element_rect(color = "gray50", fill = NA, linewidth = 0.4),
    legend.position = "bottom",
    legend.key.width = unit(2.5, "cm"),
    legend.title = element_text(face = "bold")
  )

```
Enfin, l‚Äôanalyse conjointe de la densit√© apparente et du mod√®le num√©rique de terrain (DEM) permet d‚Äôexplorer les liens entre g√©ochimie et morphologie de surface.

Les distributions r√©gionales et globales de ces deux variables montrent comment la densit√© moyenne des terrains varie avec l‚Äôaltitude, sugg√©rant des diff√©rences de composition ou de porosit√© selon les provinces.

Cette comparaison met en √©vidence les √©ventuelles corr√©lations entre composition chimique, processus volcaniques et structures topographiques h√©rit√©es de l‚Äôhistoire interne de Mercure.


```{r}
# ==================== DISTRIBUTIONS DENSIT√â & DEM (r√©gions + globales s√©par√©es) ====================

# --- Installation et chargement des packages n√©cessaires ---
if (!require(patchwork)) install.packages("patchwork")
library(patchwork)
library(ggplot2)
library(dplyr)

# --- 1. Extraction des couches ---
Density <- get_layer_as_matrix(result_array_full, 20)  # DensityGrid.dat_masked
DEM     <- get_layer_as_matrix(result_array_full, 19)  # DEM.RDS_masked
region_map <- get_layer_as_matrix(result_array_full, 28)

# --- 2. D√©finition des r√©gions ---
region_values <- c(1, 2, 3, 4, 5, 6)
region_names  <- c("High-Mg", "Al-rich", "Caloris", "Rach", "High-Al NVP", "Low-Al NVP")

# --- 3. Construction du dataframe principal ---
Region <- factor(as.vector(region_map), levels = region_values, labels = region_names)
df <- data.frame(
  Density = as.vector(Density),
  DEM     = as.vector(DEM),
  Region  = Region
) |> na.omit()

# --- 4. Palette harmonieuse ---
cols_base <- c(
  "High-Mg"     = "#E4572E",  # orange
  "Al-rich"     = "#17BEBB",  # turquoise
  "Caloris"     = "#FFC914",  # jaune
  "Rach"        = "#4B4E6D",  # bleu-gris
  "High-Al NVP" = "#76B041",  # vert clair
  "Low-Al NVP"  = "#A23B72"   # magenta
)

# === FIGURE 1 : DENSITY ===

## A. DENSITY par r√©gion
p_density_region <- ggplot(df, aes(x = Density, fill = Region, color = Region)) +
  geom_density(alpha = 0.35, linewidth = 1.0, adjust = 1.2) +
  scale_fill_manual(values = cols_base) +
  scale_color_manual(values = cols_base) +
  labs(title = "Distribution r√©gionale de la densit√©",
       x = NULL, y = "Densit√© de probabilit√©") +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    legend.position = "none"
  )

## B. DENSITY globale
p_density_global <- ggplot(df, aes(x = Density)) +
  geom_density(fill = "#A23B72", color = "#7A2853", alpha = 0.4, linewidth = 1.1) +
  labs(title = "Distribution globale de la densit√©",
       x = "Densit√© (unit√©s relatives)", y = "Densit√© de probabilit√©") +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    legend.position = "none"
  )

## Combinaison verticale
plot_density <- p_density_region / p_density_global + plot_layout(heights = c(1, 0.6))
plot_density  # <-- Affiche la figure DENSITY


# === FIGURE 2 : DEM ===

## C. DEM par r√©gion
p_dem_region <- ggplot(df, aes(x = DEM, fill = Region, color = Region)) +
  geom_density(alpha = 0.35, linewidth = 1.0, adjust = 1.2) +
  scale_fill_manual(values = cols_base) +
  scale_color_manual(values = cols_base) +
  labs(title = "Distribution r√©gionale de l'altitude (DEM)",
       x = NULL, y = "Densit√© de probabilit√©") +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    legend.position = "none"
  )

## D. DEM global
p_dem_global <- ggplot(df, aes(x = DEM)) +
  geom_density(fill = "#999999", color = "#555555", alpha = 0.4, linewidth = 1.1) +
  labs(title = "Distribution globale de l'altitude",
       x = "Altitude (m)", y = "Densit√© de probabilit√©") +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    legend.position = "none"
  )

## Combinaison verticale
plot_dem <- p_dem_region / p_dem_global + plot_layout(heights = c(1, 0.6))
plot_dem  # <-- Affiche la figure DEM

```




# R√©f√©rences

<a id="nittler2020"></a>
Nittler, L.R., Frank, E.A., Weider, S.Z., Crapster-Pregont, E., Vorburger, A., Starr, R.D. &
Solomon, S.C., 2020. global major-element maps of Mercury from four years of MESSENGER
X-Ray Spectrometer observations. Icarus, 345, 113716. https://doi.org/10.1016/j.icarus.2020.113716.



