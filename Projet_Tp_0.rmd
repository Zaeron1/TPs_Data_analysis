---
title: "Cr√©ation du tableau 3D ‚Äî Donn√©es satellites de Mercure"
author: "Alexandre Michaux, Anatole Devolder, Beniamino Orsini"
date: "`r Sys.Date()`"
output:
  html_document:
    theme: paper
    highlight: breezedark
    toc: true
    toc_float: true
    number_sections: true
    code_folding: hide
    df_print: paged
---

Ce projet s‚Äôinscrit dans le cadre de l‚Äô√©tude de la plan√®te **Mercure**, en particulier de sa **g√©ochimie de surface**.  
Gr√¢ce aux donn√©es de la sonde **MESSENGER** et √† des fichiers satellites (BMP, DAT, TIF, CSV), l‚Äôobjectif est de construire un **tableau 3D** qui rassemble diff√©rentes couches g√©ochimiques (Mg/Si, Al/Si, Fe/Si, etc.).  

Le but final est de produire des **cartes g√©ochimiques** de la surface de Mercure, afin de comparer la distribution des √©l√©ments et mieux comprendre l‚Äô√©volution magmatique de la plan√®te.

---

---

# Pr√©paration des donn√©es

Avant de pouvoir analyser et cartographier les donn√©es, il faut :  
1. **Nettoyer l‚Äôenvironnement R** pour √©viter les conflits,  
2. **Installer et charger les packages n√©cessaires** (visualisation, traitement raster, tables interactives‚Ä¶),  
3. **D√©finir les chemins** vers les dossiers o√π se trouvent les donn√©es,  
4. **V√©rifier l‚Äôexistence du dossier de donn√©es** pour garantir la reproductibilit√©.  

Cette √©tape assure une base solide pour la suite du traitement. 

## packages & chemins

Ici, on installe automatiquement les packages manquants, puis on les charge silencieusement.  
On d√©finit ensuite le dossier de donn√©es (`mercury1440x720`) et le fichier de sortie (`result_array.rds`).  
Enfin, on installe et charge le package **`mercure.ulg`**, d√©velopp√© pour traiter ce type de donn√©es.  

```{r message=FALSE, warning=FALSE}
# Nettoyage minimal (optionnel)
# rm(list = ls())
options(repos = c(CRAN = "https://cloud.r-project.org"))
# Packages requis (on installe si manquants)
need <- c("plotly", "raster", "bmp", "devtools", "rstudioapi", "DT", "viridisLite")
to_install <- setdiff(need, rownames(installed.packages()))
if (length(to_install)) install.packages(to_install, quiet = TRUE)

# Chargement
invisible(lapply(need, require, character.only = TRUE))

# Base path robuste (RStudio ou knitr)
base_path <- tryCatch(
  dirname(rstudioapi::getSourceEditorContext()$path),
  error = function(e) getwd()
)

# Dossier de donn√©es (√† adapter si besoin)
directory_path <- file.path(base_path, "mercury1440x720")
result_file    <- file.path(base_path, "result_array.rds")

# Installation/chargement du package d'analyse (GitHub)
if (!requireNamespace("mercure.ulg", quietly = TRUE)) {
  devtools::install_github("Zaeron1/mercure.ulg", upgrade = "never", quiet = TRUE)
}
library(mercure.ulg)

# S√©curit√© : le dossier de donn√©es doit exister
if (!dir.exists(directory_path)) {
  stop(paste("Le dossier de donn√©es est introuvable :", directory_path))
}
```

## Construction du tableau 3D

Pour analyser conjointement toutes les donn√©es satellites, il est n√©cessaire de les regrouper dans une seule structure : un **tableau 3D**.  
Chaque **couche** du tableau correspond √† un fichier de donn√©es (par exemple une carte Mg/Si ou un mod√®le d‚Äô√©l√©vation).  

La fonction `process_files_to_3d_array()` :  
- parcourt tous les fichiers du dossier,  
- applique les **facteurs de correction** n√©cessaires pour normaliser les valeurs,  
- redimensionne les images si besoin,  
- renvoie un **tableau 3D** o√π chaque plan correspond √† une carte.  

Cette fonction est donc au c≈ìur du projet, car elle permet d‚Äôunifier tous les formats (BMP, DAT, TIF, CSV) dans une seule base exploitable.  

```{r}
process_files_to_3d_array <- function(directory_path, correction_factors, target_dim = c(720, 1440)) {
  file_list   <- list.files(directory_path, full.names = TRUE)
  n_files     <- length(file_list)
  if (n_files == 0) stop("Aucun fichier d√©tect√© dans: ", directory_path)

  array_3d    <- array(0, dim = c(target_dim[1], target_dim[2], n_files))
  layer_names <- basename(file_list)

  apply_correction <- function(mat, factor) {
    if (is.null(factor)) factor <- 1
    mat * factor
  }

  for (i in seq_along(file_list)) {
    file_path <- file_list[i]
    file_name <- layer_names[i]
    ext <- tolower(tools::file_ext(file_name))

    if (ext == "bmp") {
      bmp_matrix <- bmp::read.bmp(file_path)
      array_3d[,,i] <- apply_correction(bmp_matrix, correction_factors[[file_name]])

    } else if (ext == "dat") {
      dat <- as.matrix(read.table(file_path, header = FALSE))
      array_3d[,,i] <- mercure.ulg::from03602180(dat)

    } else if (ext == "tif") {
      tif <- raster::raster(file_path)
      fact <- c(max(1, ncol(tif) / target_dim[2]),
                max(1, nrow(tif) / target_dim[1]))
      tif_small <- raster::aggregate(tif, fact = fact)
      mat <- as.matrix(tif_small, ncol = target_dim[2], nrow = target_dim[1])
      array_3d[,,i] <- mat * 0.5  # correction simple d'exemple

    } else if (ext == "csv") {
      lines <- gsub(",\\s+", ",", gsub("(\\d)\\s+(\\d)", "\\1,\\2", readLines(file_path)))
      tmp <- tempfile(fileext = ".csv")
      writeLines(lines, tmp)
      donnees <- read.csv(tmp, header = FALSE)
      unlink(tmp)
      array_3d[,,i] <- mercure.ulg::from03602180(as.matrix(donnees[,-1]))

    } else {
      warning("Type non support√©: ", ext, " pour le fichier ", file_name)
    }
  }

  # Info couches (utile pour navigation)
  layer_info <- data.frame(Index = seq_along(layer_names), Layer = layer_names)
  attr(array_3d, "layer_info") <- layer_info
  array_3d
}
```

## Construction/ex√©cution + r√©sum√© visuel

Une fois la fonction d√©finie, on peut l‚Äôex√©cuter avec les fichiers satellites de Mercure.  
Cette √©tape se d√©compose en plusieurs sous-parties :  
1. D√©finition et affichage des **facteurs de correction**,  
2. Construction du **tableau 3D**,  
3. R√©sum√©s rapides (**dimensions et taille m√©moire**),  
4. G√©n√©ration de la **liste des couches disponibles**.  

---

### üîπ Facteurs de correction  

Les fichiers BMP bruts sont normalis√©s entre 0 et 255.  
Afin de convertir ces valeurs en rapports g√©ochimiques (ex. Mg/Si, Al/Si), on applique un **facteur de correction sp√©cifique** √† chaque fichier.  
Ces facteurs sont list√©s dans le tableau ci-dessous :  

```{r}
correction_factors <- list(
  "mgsi.bmp" = 0.860023 / 255.0,
  "alsi.bmp" = 0.402477 / 255.0,
  "ssi.bmp"  = 0.161680 / 255.0,
  "fesi.bmp" = 0.117737 / 255.0,
  "casi.bmp" = 0.318000 / 255.0
)

# Transformation en tableau
correction_table <- data.frame(
  Fichier = names(correction_factors),
  Facteur = unlist(correction_factors)
)

# Affichage lisible (interactif si DT dispo)
if (requireNamespace("DT", quietly = TRUE)) {
  DT::datatable(correction_table,
                rownames = FALSE,
                options = list(dom = 't'),
                caption = "Facteurs de correction appliqu√©s aux fichiers BMP")
} else {
  knitr::kable(correction_table, digits = 6,
               caption = "Facteurs de correction appliqu√©s aux fichiers BMP")
}
```

### üîπ Construction du tableau 3D

La fonction process_files_to_3d_array() est appliqu√©e au dossier mercury1440x720.
Chaque fichier est lu, corrig√© et stock√© dans un tableau 3D, o√π :
	‚Ä¢	la dimension 1 correspond aux lignes (latitude),
	‚Ä¢	la dimension 2 correspond aux colonnes (longitude),
	‚Ä¢	la dimension 3 correspond aux diff√©rentes couches g√©ochimiques ou g√©ophysiques.
	
```{r}
result_array <- process_files_to_3d_array(directory_path, correction_factors)
saveRDS(result_array, file = result_file) # Sauvegarder le tableau 3D dans un fichier RDS
#result_array <- readRDS(result_file) # Lire le tableau 3D depuis le fichier RDS
rm(list=ls()[!ls() %in% c("result_array")]) # Supprimer toutes les variables sauf le tableau 3D
```

### Liste de couches disponibles

Chaque couche correspond √† un fichier source (BMP, DAT, TIF, CSV).
Le tableau ci-dessous r√©capitule les couches disponibles dans result_array.

```{r}
layer_info <- attr(result_array, "layer_info")

if (requireNamespace("DT", quietly = TRUE)) {
  DT::datatable(layer_info,
                rownames = FALSE,
                options = list(pageLength = 10),
                caption = "Liste des couches pr√©sentes dans le tableau 3D")
} else {
  knitr::kable(layer_info,
               caption = "Liste des couches pr√©sentes dans le tableau 3D")
}
```

#### Obtention d'une couche sp√©cifique
Pour acc√©der √† une couche particuli√®re, on peut utiliser son index ou son nom de fichier.

```{r}
layer_matrix <- get_layer_as_matrix(result_array, 2) # EXEMPLE: Extraire une couche sp√©cifique (index 2 ici) du tableau 3D sous forme de matrice
```
IMPORTANT: le tableau g√©n√©r√© dans la console renseigne les index qu'il faut utiliser dans les prochaines fonctions poru extraire les bonnes matrices du 3D array

# R√©sultats des analyses
Avec le tableau 3D construit, on peut d√©sormais extraire des couches sp√©cifiques pour analyse et visualisation.  
Par exemple, on peut extraire la couche DEM (index 4) et la visualiser avec une palette de couleurs adapt√©e

## Digital Elevation Model (DEM) de Mercure

```{r}
plot_matrix <- function(layer_index_or_name, main_title, legend_name, color_palette) {
  # check si l'argument est une matrice dans l'environment ou un index √† extraire de result_array
  if (is.matrix(layer_index_or_name)) {
    layer_matrix <- layer_index_or_name
  } else if (is.numeric(layer_index_or_name)) {
    if (layer_index_or_name < 1 || layer_index_or_name > dim(result_array)[3]) {
      stop("Layer index out of bounds.")
    }
    layer_matrix <- get_layer_as_matrix(result_array, layer_index_or_name)
  } else {
    stop("The input must be either a matrix or a numeric index of a layer.")
  }

  # Create a plotly heatmap
  plot_ly(
    z = layer_matrix,
    type = "heatmap",
    colors = colorRamp(c("blue", "cyan", "yellowgreen", "yellow", "orange", "orangered", "darkred")),
    showscale = TRUE,
    colorbar = list(title = legend_name)
  ) %>%
    layout(
      title = main_title,
      xaxis = list(
        title = "Longitude",
        tickvals = seq(0, ncol(layer_matrix), by = ncol(layer_matrix) / 12),
        ticktext = paste0(seq(-180, 180, length.out = 13), "¬∞")
      ),
      yaxis = list(
        title = "Latitude",
        tickvals = seq(0, nrow(layer_matrix), by = nrow(layer_matrix) / 12),
        ticktext = paste0(seq(90, -90, length.out = 13), "¬∞"), autorange = "reversed"
      )
    )
}
```
```{r}
# Affichage de la couche 4 (DEM) en heatmap
plot_matrix(
  layer_index_or_name = 4, 
  main_title = "Carte du DEM de Mercure üåç",
  legend_name = "√âl√©vation (m)",
  color_palette = NULL
)
```

## Classifcation en d√©ciles g√©ochimiques
La classification en d√©ciles permet de segmenter les donn√©es g√©ochimiques en 10 cat√©gories √©gales.  
Cela facilite l‚Äôinterpr√©tation des variations spatiales des rapports √©l√©mentaires (ex. Mg/Si).  
La fonction `classify_matrix()` prend en entr√©e une couche sp√©cifique et renvoie une matrice classifi√©e.

```{r}
classify_matrix <- function(layer_index){
  if (layer_index < 1 || layer_index > dim(result_array)[3]) {
    stop("Layer index out of bounds.")
  }
  layer_matrix <- get_layer_as_matrix(result_array, layer_index)
  quantile <- quantile(layer_matrix, probs = seq(0, 1, by = 0.1))  # Calcul des quantile
  labels <- c("Lowest","Very Very Low", "Very Low", "Low", "Medium Low", "Medium", "Medium High", "High", "Very High", "Very Very High", "Highest")  # √âtiquettes de classification
  classes <- cut(as.vector(layer_matrix), breaks = c(quantile, Inf), labels = labels, include.lowest = TRUE)  # Classification des valeurs
  class_matrix <- matrix(as.numeric(classes), nrow = nrow(layer_matrix), byrow = FALSE)  # Conversion en matrice num√©rique
  return(class_matrix)
}
```




